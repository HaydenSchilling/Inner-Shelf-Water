fitA <- lm(Biomass ~ Bathy , data = dat3)
(fitA)
summary(fitA)
fitA <- lm(Biomass ~ (-Bathy) , data = dat3)
summary(fitA)
dat3$Bathy <- dat2$Bathy * -1
fitA <- lm(Biomass ~ Bathy ,data = dat3)
fitA <- lm(Biomass ~ Bathy, data = dat3)
summary(fitA)
coefs <- coef(fitA)
pA <- ggplot(dat2, aes(x = -Bathy, y = Biomass, col = site)) + geom_point() +
geom_smooth(method = "lm") + facet_wrap(~site) + xlim(0, 300) + theme_classic() +
geom_abline(slope = coefs[2], intercept = coefs[1])
pA
pA <- ggplot(dat2, aes(x = -Bathy, y = Biomass, col = site)) + geom_point() +
geom_smooth(method = "lm") + facet_wrap(~site) + xlim(0, 300) + theme_classic() +
geom_abline(slope = coefs[2], intercept = coefs[1], lty = 2)
pA
fitB <- lm(ParetoSlope ~ Bathy, data = dat3)
summary(fitB)
coefsB <- coef(fitB)
pB <- ggplot(dat2, aes(x = -Bathy, y = ParetoSlope, col = site)) + geom_point() +
geom_smooth(method = "lm") + facet_wrap(~site) +
geom_abline(slope = coefsB[2], intercept = coefsB[1], lty = 2)
pB
fitC <- lm(GeoMn ~ Bathy, data = dat3)
summary(fitC)
coefsC <- coef(fitC)
pC <- ggplot(dat2, aes(x = -Bathy, y = GeoMn, col = site)) + geom_point() +
geom_smooth(method = "lm") + facet_wrap(~site) +  theme_classic() +
geom_abline(slope = coefsC[2], intercept = coefsC[1], lty = 2)
pC
pA <- ggplot(dat2, aes(x = -Bathy, y = Biomass)) + geom_point() +
geom_smooth(method = "lm") + facet_wrap(~site) + xlim(0, 300) + theme_classic() +
geom_abline(slope = coefs[2], intercept = coefs[1], lty = 2)
pA
ggsave("plots/zoop/Biomass by Bathymetry_300m.pdf", width=10, height=8)
ggsave("plots/zoop/Biomass by Bathymetry_300m.png", width=10, height=8, dpi = 600)
pA <- ggplot(dat2, aes(x = -Bathy, y = Biomass)) + geom_point() +
geom_smooth(method = "lm") + facet_wrap(~site) + theme_classic() +
geom_abline(slope = coefs[2], intercept = coefs[1], lty = 2)
pA
dat3 <- dat3 %>% filter(Bathy >= -300)
fitA <- lm(Biomass ~ Bathy, data = dat3)
summary(fitA)
coefs <- coef(fitA)
pA <- ggplot(dat2, aes(x = -Bathy, y = Biomass)) + geom_point() +
geom_smooth(method = "lm") + facet_wrap(~site) + xlim(0, 300) + theme_classic() +
geom_abline(slope = coefs[2], intercept = coefs[1], lty = 2)
pA
View(dat3)
pA <- ggplot(dat2, aes(x = Bathy, y = Biomass)) + geom_point() +
geom_smooth(method = "lm") + facet_wrap(~site) + xlim(0, 300) + theme_classic() +
geom_abline(slope = coefs[2], intercept = coefs[1], lty = 2)
pA
dat2 <- mydata %>% filter(Depth >10 & Depth >51)
dat2$site <- factor(dat2$site, levels = c("CapeByron", "EvansHead", "NorthSolitary", "DiamondHead"))
dat3 <- dat2
dat3$Bathy <- dat2$Bathy * -1
dat3 <- dat3 %>% filter(Bathy <= 300)
fitA <- lm(Biomass ~ Bathy, data = dat3)
summary(fitA)
coefs <- coef(fitA)
pA <- ggplot(dat2, aes(x = Bathy, y = Biomass)) + geom_point() +
geom_smooth(method = "lm") + facet_wrap(~site) + xlim(0, 300) + theme_classic() +
geom_abline(slope = coefs[2], intercept = coefs[1], lty = 2)
pA
pA <- ggplot(dat2, aes(x = -Bathy, y = Biomass)) + geom_point() +
geom_smooth(method = "lm") + facet_wrap(~site) + xlim(0, 300) + theme_classic() +
geom_abline(slope = coefs[2], intercept = coefs[1], lty = 2)
pA
dat3 <- dat2
dat3$Bathy <- dat2$Bathy * -1
fitA <- lm(Biomass ~ Bathy, data = dat3)
summary(fitA)
coefs <- coef(fitA)
pA <- ggplot(dat2, aes(x = -Bathy, y = Biomass)) + geom_point() +
geom_smooth(method = "lm") + facet_wrap(~site) + theme_classic() +
geom_abline(slope = coefs[2], intercept = coefs[1], lty = 2)
pA
ggsave("plots/zoop/Biomass by Bathymetry.pdf", width=10, height=8)
ggsave("plots/zoop/Biomass by Bathymetry.png", width=10, height=8, dpi = 600)
fitB <- lm(ParetoSlope ~ Bathy, data = dat3)
summary(fitB)
coefsB <- coef(fitB)
pB <- ggplot(dat2, aes(x = -Bathy, y = ParetoSlope, col = site)) + geom_point() +
geom_smooth(method = "lm") + facet_wrap(~site) +  theme_classic() +
geom_abline(slope = coefsB[2], intercept = coefsB[1], lty = 2)
pB
ggsave("plots/zoop/Slope by Bathymetry.pdf", width=10, height=8)
ggsave("plots/zoop/Slope by Bathymetry.png", width=10, height=8, dpi = 600)
fitC <- lm(GeoMn ~ Bathy, data = dat3)
summary(fitC)
coefsC <- coef(fitC)
pC <- ggplot(dat2, aes(x = -Bathy, y = GeoMn, col = site)) + geom_point() +
geom_smooth(method = "lm") + facet_wrap(~site) +  theme_classic() +
geom_abline(slope = coefsC[2], intercept = coefsC[1], lty = 2)
pC
ggsave("plots/zoop/Size by Bathymetry.pdf", width=10, height=8)
ggsave("plots/zoop/Size by Bathymetry.png", width=10, height=8, dpi = 600)
### Geo_Mn Size #  done
### interpoLation and plots
for (j in sites){
mydata2 <- filter(mydata, site == j)
mydata2 <-  mydata2 %>% drop_na(GeoMn, Depth) %>% filter(GeoMn != Inf)
Bathy2 <- filter(Bathy, site == j)
#fit1 <- interp(x = mydata2$Distance_Coast, y = -mydata2$Depth, z = log10(mydata2$Biomass),
#               nx = 100, ny = 100)
fit1 <- with(mydata2, interp(x = Distance_Coast, y = -Depth, z = GeoMn*1000, nx = 100, ny = 100))
df <- melt(fit1$z, na.rm = TRUE)
names(df) <- c("x", "y", "GeoMn")
df$Distance_Coast <- fit1$x[df$x]
df$Depth <- fit1$y[df$y]
ggplot(data = df, mapping = aes(x = Distance_Coast, y = Depth, z = GeoMn)) +
geom_tile(aes(fill = GeoMn)) +
geom_contour(colour = "white") + #, binwidth = 0.125
scale_fill_distiller(palette = "Spectral", direction = -1, # "YlOrRd"
limits = c(min(mydata$GeoMn*1000, na.rm = TRUE), max(mydata$GeoMn*1000, na.rm = TRUE))) +
geom_line(data = mydata2, mapping = aes(x = Distance_Coast, y = -Depth), alpha = 0.5) +
geom_point(data = mydata2, mapping = aes(x = Distance_Coast, y = -Depth), alpha = 0.5) +
geom_ribbon(data= Bathy2, aes(x = Distance_Coast, ymax = Bathymetry, ymin=-200), inherit.aes = FALSE, fill = "grey60") +
ggtitle(paste0("Geometric Mean Size at ", j))
ggsave(paste0('plots/zoop/',j,"_GeoMn",'.pdf'),width = 10, height = 5)
ggsave(paste0('plots/zoop/',j,"_GeoMn",'.png'),width = 10, height = 5, dpi = 600)
}
#install.packages("akima")
library(akima)
library(ggplot2)
library(reshape2)
library(tidyverse)
mydata <- read_csv("Data/SS2004_SeaSoarData_with_GEBCO.csv")
str(mydata)
head(mydata)
mydata <- mydata %>%
mutate(site = case_when(site = str_detect(File,"SS0408_023") ~ "CapeByron",
site = str_detect(File,"SS0408_021") ~ "EvansHead",
site = str_detect(File,"SS0408_010") ~ "NorthSolitary",
site = str_detect(File,"SS0408_008") ~ "DiamondHead"),
site = as.factor(site))
### Get distance from shore
### Get distance from shore
library(geosphere)
mydata$Distance_Coast = 0
for (i in 1:nrow(mydata)){
if (mydata$site[i] == "CapeByron") {
mydata$Distance_Coast[i] = distm(c(153.58, -28.6), c(mydata$Lon[i], mydata$Lat[i]), fun = distHaversine)
}
if (mydata$site[i] == "DiamondHead") {
mydata$Distance_Coast[i] = distm(c(152.75, -31.8), c(mydata$Lon[i], mydata$Lat[i]), fun = distHaversine)
}
if (mydata$site[i] == "EvansHead") {
mydata$Distance_Coast[i] = distm(c(153.48, -29.0), c(mydata$Lon[i], mydata$Lat[i]), fun = distHaversine)
}
if (mydata$site[i] == "NorthSolitary") {
mydata$Distance_Coast[i] = distm(c(153.23, -30.0), c(mydata$Lon[i], mydata$Lat[i]), fun = distHaversine)
}
}
### Get Bathymetry and add distance from coast
Bathy <- read.csv("Data/Transect Bathymetry.csv", header = T)
Bathy <- subset(Bathy, Bathymetry < -1 & Bathymetry >= -200)
Bathy$Distance_Coast = 0
for (i in 1:nrow(Bathy)){
if (Bathy$site[i] == "CapeByron") {
Bathy$Distance_Coast[i] = distm(c(153.58, -28.6), c(Bathy$Longitude[i], Bathy$Latitude[i]), fun = distHaversine)
}
if (Bathy$site[i] == "DiamondHead") {
Bathy$Distance_Coast[i] = distm(c(152.75, -31.8), c(Bathy$Longitude[i], Bathy$Latitude[i]), fun = distHaversine)
}
if (Bathy$site[i] == "EvansHead") {
Bathy$Distance_Coast[i] = distm(c(153.48, -29.0), c(Bathy$Longitude[i], Bathy$Latitude[i]), fun = distHaversine)
}
if (Bathy$site[i] == "NorthSolitary") {
Bathy$Distance_Coast[i] = distm(c(153.23, -30.0), c(Bathy$Longitude[i], Bathy$Latitude[i]), fun = distHaversine)
}
}
# # variables to loop through
# vars = c("Temp", "Salt","GeoMn")# "NBSS.Slope",
# #sites to loop through
sites <- levels(mydata$site)
#
# # # Testing
# # for (i in vars){
# #
# #   p1 <- ggplot(mydata, aes(x = long3, y = -Depth, col = get(i))) + geom_point() +
# #     facet_wrap(~OPC_site, scales = "free_x") + theme_bw()
# #   print(p1)
# # }
### Geo_Mn Size #  done
### interpoLation and plots
for (j in sites){
mydata2 <- filter(mydata, site == j)
mydata2 <-  mydata2 %>% drop_na(GeoMn, Depth) %>% filter(GeoMn != Inf)
Bathy2 <- filter(Bathy, site == j)
#fit1 <- interp(x = mydata2$Distance_Coast, y = -mydata2$Depth, z = log10(mydata2$Biomass),
#               nx = 100, ny = 100)
fit1 <- with(mydata2, interp(x = Distance_Coast, y = -Depth, z = GeoMn*1000, nx = 100, ny = 100))
df <- melt(fit1$z, na.rm = TRUE)
names(df) <- c("x", "y", "GeoMn")
df$Distance_Coast <- fit1$x[df$x]
df$Depth <- fit1$y[df$y]
ggplot(data = df, mapping = aes(x = Distance_Coast, y = Depth, z = GeoMn)) +
geom_tile(aes(fill = GeoMn)) +
geom_contour(colour = "white") + #, binwidth = 0.125
scale_fill_distiller(palette = "Spectral", direction = -1, # "YlOrRd"
limits = c(min(mydata$GeoMn*1000, na.rm = TRUE), max(mydata$GeoMn*1000, na.rm = TRUE))) +
geom_line(data = mydata2, mapping = aes(x = Distance_Coast, y = -Depth), alpha = 0.5) +
geom_point(data = mydata2, mapping = aes(x = Distance_Coast, y = -Depth), alpha = 0.5) +
geom_ribbon(data= Bathy2, aes(x = Distance_Coast, ymax = Bathymetry, ymin=-200), inherit.aes = FALSE, fill = "grey60") +
ggtitle(paste0("Geometric Mean Size at ", j))
ggsave(paste0('plots/zoop/',j,"_GeoMn",'.pdf'),width = 10, height = 5)
ggsave(paste0('plots/zoop/',j,"_GeoMn",'.png'),width = 10, height = 5, dpi = 600)
}
pC <- ggplot(dat2, aes(x = -Bathy, y = GeoMn*1000, col = site)) + geom_point() +
geom_smooth(method = "lm") + facet_wrap(~site) +  theme_classic() +
geom_abline(slope = coefsC[2], intercept = coefsC[1], lty = 2)
pC
ggsave("plots/zoop/Size by Bathymetry.pdf", width=10, height=8)
ggsave("plots/zoop/Size by Bathymetry.png", width=10, height=8, dpi = 600)
hist(zoo_dat$Bathy)
## MODIS Time Series leading up to the transects
## Hayden Schilling using code from Jason Everett for IMOS Download
## Use the end and start of each transect and look at a month prior
library(tidyverse)
# First get Transects
mydata <- read_csv("Data/SS2004_SeaSoarData.csv")
str(mydata)
head(mydata)
mydata <- mydata %>%
mutate(site = case_when(site = str_detect(File,"SS0408_023") ~ "CapeByron",
site = str_detect(File,"SS0408_021") ~ "EvansHead",
site = str_detect(File,"SS0408_010") ~ "NorthSolitary",
site = str_detect(File,"SS0408_008") ~ "DiamondHead"),
site = as.factor(site))
### Get distance from shore
### Get distance from shore
library(geosphere)
mydata$Distance_Coast = 0
for (i in 1:nrow(mydata)){
if (mydata$site[i] == "CapeByron") {
mydata$Distance_Coast[i] = distm(c(153.58, -28.6), c(mydata$Lon[i], mydata$Lat[i]), fun = distHaversine)
}
if (mydata$site[i] == "DiamondHead") {
mydata$Distance_Coast[i] = distm(c(152.75, -31.8), c(mydata$Lon[i], mydata$Lat[i]), fun = distHaversine)
}
if (mydata$site[i] == "EvansHead") {
mydata$Distance_Coast[i] = distm(c(153.48, -29.0), c(mydata$Lon[i], mydata$Lat[i]), fun = distHaversine)
}
if (mydata$site[i] == "NorthSolitary") {
mydata$Distance_Coast[i] = distm(c(153.23, -30.0), c(mydata$Lon[i], mydata$Lat[i]), fun = distHaversine)
}
}
### Identify start and end points
datF <- mydata %>% group_by(site) %>% summarise(West_Long = min(Lon), East_Long = max(Lon),
Lat = min(Lat), Date = as.POSIXct(min(datestr),
format= "%d-%b-%Y %H:%M:%OS"))
datF
str(datF)
### Make a dataframe for each site
sites = levels(datF$site)
sites
df_list <- list()
for (i in sites){
dat2 <- filter(datF, site == i)
assign(paste0("dat_",i,"_West"), data.frame(Longitude = dat2$West_Long[1], Latitude = dat2$Lat[1],
Date = seq.Date(from = as.Date(dat2$Date[1]) , by = -1, length.out = 30),
Location = paste0(i,"_West")))
assign(paste0("dat_",i,"_East"), data.frame(Longitude = dat2$East_Long[1], Latitude = dat2$Lat[1],
Date = seq.Date(from = as.Date(dat2$Date[1]) , by = -1, length.out = 30),
Location = paste0(i,"_East")))
}
# merge into a single dataframe
df_list <- list(dat_CapeByron_East, dat_CapeByron_West, dat_DiamondHead_East, dat_DiamondHead_West,
dat_EvansHead_East, dat_EvansHead_West, dat_NorthSolitary_East, dat_NorthSolitary_West)
full_dat <- bind_rows(df_list)
full_dat$Location <- as.factor(full_dat$Location)
str(full_dat)
## Load download code
source("../../../IMOS Data/IMOS_Toolbox/fIMOS_MatchMODIS.R")
# Possible products
# pr <- c("sst_quality", "sst", "picop_brewin2012in", "picop_brewin2010at", "par",
#         "owtd", "npp_vgpm_eppley_oc3", "npp_vgpm_eppley_gsm", "nanop_brewin2012in",
#         "nanop_brewin2010at", "l2_flags", "ipar", "dt", "chl_oc3", "chl_gsm", "K_490")
pr <- c("chl_oc3", "sst") # select products here eg: "chl_oc3", "sst"
# Set resolutions
res_temp <- "1d" # temporal resolutions
res_spat <- 10 # Return the average of res_spat x res_spat pixels
dat <- fIMOS_MatchMODIS(full_dat, pr, res_temp, res_spat)
str(dat)
dat2 <- str_split_fixed(dat$Location, pattern = "_", n = 2)
dat$Transect <- dat2[,1]
dat$East_West <- dat2[,2]
## Reorder levels of the factors
dat$East_West <- factor(dat$East_West, levels = c("West", "East"))
dat$Transect <- factor(dat$Transect, levels = c("CapeByron", "EvansHead", "NorthSolitary", "DiamondHead"))
# load Transect dates file
date_dat <- read_csv("Transect Sample Dates.csv")
date_dat$Date <- as.Date(date_dat$Date, format = "%d/%m/%Y")
date_dat$East_West <- factor(date_dat$East_West, levels = c("West", "East"))
date_dat$Transect <- factor(date_dat$Transect, levels = c("CapeByron", "EvansHead", "NorthSolitary", "DiamondHead"))
str(date_dat)
p1 <- ggplot(dat, aes(x = Date, y = chl_oc3_1d)) + geom_line() + geom_point() +
facet_grid(Transect~East_West) + theme_classic() +
geom_vline(data = date_dat, aes(xintercept =  Date), col = "red", lty = 2) +
ylab ("MODIS Chl_a")
p1
dat$chl_oc3_1d[dat$chl_oc3_1d > 10] <- 10
p1 <- ggplot(dat, aes(x = Date, y = chl_oc3_1d)) + geom_line() + geom_point() +
facet_grid(Transect~East_West) + theme_classic() +
geom_vline(data = date_dat, aes(xintercept =  Date), col = "red", lty = 2) +
ylab ("MODIS Chl_a")
p1
p1 <- ggplot(dat, aes(x = Date, y = log10(chl_oc3_1d + 0.5*min(dat$chl_oc3_1d)))) + geom_line() + geom_point() +
facet_grid(Transect~East_West) + theme_classic() +
geom_vline(data = date_dat, aes(xintercept =  Date), col = "red", lty = 2) +
ylab ("MODIS Chl_a")
p1
p1 <- ggplot(dat, aes(x = Date, y = log10(chl_oc3_1d + 0.5*min(dat$chl_oc3_1d, na.rm = T)))) + geom_line() + geom_point() +
facet_grid(Transect~East_West) + theme_classic() +
geom_vline(data = date_dat, aes(xintercept =  Date), col = "red", lty = 2) +
ylab ("MODIS Chl_a")
p1
p1 <- ggplot(dat, aes(x = Date, y = log10(chl_oc3_1d + 0.5*min(dat$chl_oc3_1d, na.rm = T)))) + geom_line() + geom_point() +
facet_grid(Transect~East_West) + theme_classic() +
geom_vline(data = date_dat, aes(xintercept =  Date), col = "red", lty = 2) +
ylab ("log10(MODIS Chl_a)")
p1
ggsave("plots/MODIS Chl_a month prior.png", height = 14.8, width = 21, units = "cm", dpi = 600)
p2 <- ggplot(dat, aes(x = Date, y = sst_1d)) + geom_line() +
facet_grid(Transect~East_West) + theme_classic() +
geom_vline(data = date_dat, aes(xintercept =  Date), col = "red", lty = 2)
p2
p1
### ADCP plots
#install.packages("akima")
library(akima)
library(tidyverse)
library(reshape2)
mydata <- read.csv("Data/ADP_tows_final_300419.csv")
str(mydata)
head(mydata)
### Get distance from shore
library(geosphere)
mydata$Distance_Coast = 0
for (i in 1:nrow(mydata)){
if (mydata$OPC_site[i] == "CB") {
mydata$Distance_Coast[i] = distm(c(153.58, -28.6), c(mydata$Lon[i], mydata$Lat[i]), fun = distHaversine)
}
if (mydata$OPC_site[i] == "DH") {
mydata$Distance_Coast[i] = distm(c(152.75, -31.8), c(mydata$Lon[i], mydata$Lat[i]), fun = distHaversine)
}
if (mydata$OPC_site[i] == "EH") {
mydata$Distance_Coast[i] = distm(c(153.48, -29.0), c(mydata$Lon[i], mydata$Lat[i]), fun = distHaversine)
}
if (mydata$OPC_site[i] == "NS") {
mydata$Distance_Coast[i] = distm(c(153.23, -30.0), c(mydata$Lon[i], mydata$Lat[i]), fun = distHaversine)
}
}
### Get Bathymetry and add distance from coast
Bathy <- read.csv("Data/Transect Bathymetry.csv", header = T)
Bathy <- subset(Bathy, Bathymetry < -1 & Bathymetry > -300)
Bathy$Distance_Coast = 0
for (i in 1:nrow(Bathy)){
if (Bathy$site[i] == "CapeByron") {
Bathy$Distance_Coast[i] = distm(c(153.58, -28.6), c(Bathy$Longitude[i], Bathy$Latitude[i]), fun = distHaversine)
}
if (Bathy$site[i] == "DiamondHead") {
Bathy$Distance_Coast[i] = distm(c(152.75, -31.8), c(Bathy$Longitude[i], Bathy$Latitude[i]), fun = distHaversine)
}
if (Bathy$site[i] == "EvansHead") {
Bathy$Distance_Coast[i] = distm(c(153.48, -29.0), c(Bathy$Longitude[i], Bathy$Latitude[i]), fun = distHaversine)
}
if (Bathy$site[i] == "NorthSolitary") {
Bathy$Distance_Coast[i] = distm(c(153.23, -30.0), c(Bathy$Longitude[i], Bathy$Latitude[i]), fun = distHaversine)
}
}
# velocity rotation (to align with coastline):
# # Cb = 356 degree, EH = 13 degree, NS = 15 degree, DH = 19 degree
## Matlab code from amandine
##  rot_deg_angle=-22 # to change
#
#
## UCUR_shore=cosd(rot_deg_angle).*UCUR+sind(rot_deg_angle).*VCUR; % across-shelf
## VCUR_shore=-sind(rot_deg_angle).*UCUR+cosd(rot_deg_angle).*VCUR; % along-shelf
mydata$U_shore = 0
mydata$V_shore = 0
for (i in 1:nrow(mydata)){
if (mydata$OPC_site[i] == "CB") {
rot_deg_angle= -356
mydata$U_shore[i] = cos(rot_deg_angle*pi/180)*mydata$U[i] + sin(rot_deg_angle*pi/180)*mydata$V[i]
mydata$V_shore[i] = sin(rot_deg_angle*pi/180)*mydata$U[i] + cos(rot_deg_angle*pi/180)*mydata$V[i]
}
if (mydata$OPC_site[i] == "DH") {
rot_deg_angle= -19
mydata$U_shore[i] = cos(rot_deg_angle*pi/180)*mydata$U[i] + sin(rot_deg_angle*pi/180)*mydata$V[i]
mydata$V_shore[i] = sin(rot_deg_angle*pi/180)*mydata$U[i] + cos(rot_deg_angle*pi/180)*mydata$V[i]
}
if (mydata$OPC_site[i] == "EH") {
rot_deg_angle= -13
mydata$U_shore[i] = cos(rot_deg_angle*pi/180)*mydata$U[i] + sin(rot_deg_angle*pi/180)*mydata$V[i]
mydata$V_shore[i] = sin(rot_deg_angle*pi/180)*mydata$U[i] + cos(rot_deg_angle*pi/180)*mydata$V[i]
}
if (mydata$OPC_site[i] == "NS") {
rot_deg_angle= -15
mydata$U_shore[i] = cos(rot_deg_angle*pi/180)*mydata$U[i] + sin(rot_deg_angle*pi/180)*mydata$V[i]
mydata$V_shore[i] = sin(rot_deg_angle*pi/180)*mydata$U[i] + cos(rot_deg_angle*pi/180)*mydata$V[i]
}
}
#vars = c("U_shore", "V_shore", "U", "V")
sites = c("DH", "NS", "EH", "CB")
sitesB = c("DiamondHead", "NorthSolitary", "EvansHead", "CapeByron")
### Test
datdat <- mydata %>% group_by(OPC_Site) %>% summarise(maxV = max(V_shore), maxV = max(U_shore))
### Test
datdat <- mydata %>% group_by(OPC_site) %>% summarise(maxV = max(V_shore), maxV = max(U_shore))
datdat
### Test
datdat <- mydata %>% group_by(OPC_site) %>% summarise(maxV = min(V_shore), maxV = min(U_shore))
datdat
View(mydata)
View(datdat)
### ADCP plots
#install.packages("akima")
library(akima)
library(tidyverse)
library(reshape2)
mydata <- read.csv("Data/ADP_tows_final_300419.csv")
str(mydata)
head(mydata)
### Get distance from shore
library(geosphere)
mydata$Distance_Coast = 0
for (i in 1:nrow(mydata)){
if (mydata$OPC_site[i] == "CB") {
mydata$Distance_Coast[i] = distm(c(153.58, -28.6), c(mydata$Lon[i], mydata$Lat[i]), fun = distHaversine)
}
if (mydata$OPC_site[i] == "DH") {
mydata$Distance_Coast[i] = distm(c(152.75, -31.8), c(mydata$Lon[i], mydata$Lat[i]), fun = distHaversine)
}
if (mydata$OPC_site[i] == "EH") {
mydata$Distance_Coast[i] = distm(c(153.48, -29.0), c(mydata$Lon[i], mydata$Lat[i]), fun = distHaversine)
}
if (mydata$OPC_site[i] == "NS") {
mydata$Distance_Coast[i] = distm(c(153.23, -30.0), c(mydata$Lon[i], mydata$Lat[i]), fun = distHaversine)
}
}
### Get Bathymetry and add distance from coast
Bathy <- read.csv("Data/Transect Bathymetry.csv", header = T)
Bathy <- subset(Bathy, Bathymetry < -1 & Bathymetry > -300)
Bathy$Distance_Coast = 0
for (i in 1:nrow(Bathy)){
if (Bathy$site[i] == "CapeByron") {
Bathy$Distance_Coast[i] = distm(c(153.58, -28.6), c(Bathy$Longitude[i], Bathy$Latitude[i]), fun = distHaversine)
}
if (Bathy$site[i] == "DiamondHead") {
Bathy$Distance_Coast[i] = distm(c(152.75, -31.8), c(Bathy$Longitude[i], Bathy$Latitude[i]), fun = distHaversine)
}
if (Bathy$site[i] == "EvansHead") {
Bathy$Distance_Coast[i] = distm(c(153.48, -29.0), c(Bathy$Longitude[i], Bathy$Latitude[i]), fun = distHaversine)
}
if (Bathy$site[i] == "NorthSolitary") {
Bathy$Distance_Coast[i] = distm(c(153.23, -30.0), c(Bathy$Longitude[i], Bathy$Latitude[i]), fun = distHaversine)
}
}
# velocity rotation (to align with coastline):
# # Cb = 356 degree, EH = 13 degree, NS = 15 degree, DH = 19 degree
## Matlab code from amandine
##  rot_deg_angle=-22 # to change
#
#
## UCUR_shore=cosd(rot_deg_angle).*UCUR+sind(rot_deg_angle).*VCUR; % across-shelf
## VCUR_shore=-sind(rot_deg_angle).*UCUR+cosd(rot_deg_angle).*VCUR; % along-shelf
mydata$U_shore = 0
mydata$V_shore = 0
for (i in 1:nrow(mydata)){
if (mydata$OPC_site[i] == "CB") {
rot_deg_angle= -356
mydata$U_shore[i] = cos(rot_deg_angle*pi/180)*mydata$U[i] + sin(rot_deg_angle*pi/180)*mydata$V[i]
mydata$V_shore[i] = sin(rot_deg_angle*pi/180)*mydata$U[i] + cos(rot_deg_angle*pi/180)*mydata$V[i]
}
if (mydata$OPC_site[i] == "DH") {
rot_deg_angle= -19
mydata$U_shore[i] = cos(rot_deg_angle*pi/180)*mydata$U[i] + sin(rot_deg_angle*pi/180)*mydata$V[i]
mydata$V_shore[i] = sin(rot_deg_angle*pi/180)*mydata$U[i] + cos(rot_deg_angle*pi/180)*mydata$V[i]
}
if (mydata$OPC_site[i] == "EH") {
rot_deg_angle= -13
mydata$U_shore[i] = cos(rot_deg_angle*pi/180)*mydata$U[i] + sin(rot_deg_angle*pi/180)*mydata$V[i]
mydata$V_shore[i] = sin(rot_deg_angle*pi/180)*mydata$U[i] + cos(rot_deg_angle*pi/180)*mydata$V[i]
}
if (mydata$OPC_site[i] == "NS") {
rot_deg_angle= -15
mydata$U_shore[i] = cos(rot_deg_angle*pi/180)*mydata$U[i] + sin(rot_deg_angle*pi/180)*mydata$V[i]
mydata$V_shore[i] = sin(rot_deg_angle*pi/180)*mydata$U[i] + cos(rot_deg_angle*pi/180)*mydata$V[i]
}
}
### Test
#datdat <- mydata %>% group_by(OPC_site) %>% summarise(maxV = min(V_shore), maxV = min(U_shore))
#datdat
### Test
datdat <- mydata %>% group_by(OPC_site) %>% summarise(maxV = min(V_shore), maxV = min(U_shore))
datdat
### Test
datdat <- mydata %>% group_by(OPC_site) %>% summarise(maxV = min(V_shore), maxV = min(V_shore))
datdat
### Test
datdat <- mydata %>% group_by(OPC_site) %>% summarise(maxV = min(V_shore), maxU = min(U_shore))
datdat
View(mydata)
### Test
datdat <- mydata %>% group_by(OPC_site) %>% summarise(maxV = min(V_shore), minV = max(V_shore),
maxU = min(U_shore), minU = max(U_shore))
datdat
